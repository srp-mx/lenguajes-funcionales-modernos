\documentclass[main.tex]{subfiles}
\usepackage{util/estilo}

\begin{document}
Con el fin de poder obtener los archivos ejecutables de nuestros programas,
decidimos implementar un módulo encargado de generar el programa equivalente
en C++ para entonces aprovechar el compilador g++. Tenemos dos implementaciones
de este proceso, una que lleva a cabo una
evaluación estricta o ansiosa y otra que permite la evaluación perezosa.

La idea de la generación de código estricto consiste en los siguientes puntos:
\begin{itemize}
\item Definir una estructura $Value$ en C++ que puede contener una cadena o una
  función, 
\item Función $Apply$ que dadas dos instancias $f$ y $x$ de tipo $Value$
  permite aplicar el primero al segundo según sea el caso:
  \begin{itemize}
  \item Cadena y función $\rightarrow$ evalúa la función con la cadena vacía
    como parámetro y si el resultado es una cadena, la concatena a la primera.
    \item Cadena y cadena $\rightarrow$ concatena ambas cadenas.
    \item Función y cualquier valor $\rightarrow$ aplica la función al valor.
    \item Otro caso $\rightarrow$ ocurre un error.
  \end{itemize}
\item Implementar el comportamiento de los combinadores $S$, $K$, $I$, $B$, $C$
  y algunas variantes $Bs$, $Cp$ y $Sp$, así como las versiones $n$-arias de
  $S$, $B$ y $C$ que sean usadas en el programa SKI dadas por el algoritmo de
  la sección \ref{sssec:lambda-ski}.

\item Gracias a estas definiciones lo que sigue es reemplazar las
  expresiones del programa fuente a su definición en C++ que construimos
  con anterioridad, valor que almacenamos en una variable
  \textit{ProgramExpr}.

\item Se define el método \textit{main} en el que se aplica el programa
  a cada argumento de línea de comandos mediante la función \textit{Apply}
  y se imprime el resultado.  
\end{itemize}

La diferencia con la versión de evaluación perezosa es que en lugar de tratar
de ejecutar directamente la expresión construida en la traducción a C++, se
construye una estructura DAG, con nodos internos de aplicación y hojas de
combinadores y constantes, que se \textit{evoluciona} paso por paso. Esto lo
vemos con mayor detalle en la sección \ref{sssec:graph-red}.

Se puede enriquecer al cálculo SKI al introducir nuevos combinadores, y al
realizar esta evolución expandiendo cada combinador lo más a la izquierda
posible, garantizamos la perezosidad (\textit{lazyness}). Por ello, que se dice
que SKI es completamente perezoso tras aplicarle dichas optimizaciones
descritas por Peyton \parencite{peytonjones1987the}, las cuales discutimos en
la siguiente sección.
\end{document}
