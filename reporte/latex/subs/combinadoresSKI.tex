\documentclass[main.tex]{subfiles}
\usepackage{util/estilo}

\begin{document}
SKI es un sistema de cálculo que consta de los operadores $S$, $K$ e $I$.\cite{lambdaToSKI}
Decimos que estos $3$ combinadores son supercombinadores.\cite{peytonjones1987the}\\
Un supercombinador $S$ es una expresión lambda de la forma\cite{peytonjones1987the}:
\begin{center}
    $\lambda x_1, \lambda x_2,\ldots, \lambda x_n.E$ con una aridad de $n$
\end{center}
En dónde se cumplen las siguientes condiciones:\cite{peytonjones1987the}
\begin{itemize}
    \item $S$ no cuenta con variables libres
    \item Cualquier abstracción lambda en $E$ es un supercombinador
    \item $n \geq 0$, es decir, no necesariamente cuenta con lambdas.
\end{itemize}
En otras palabras, un supercombinador es una expresión lambda que no cuenta con variables libres,
en ninguna parte y que cuenta con por lo menos un argumento.\\
Algunos ejemplos de esto son:\cite{peytonjones1987the}
\begin{center}
    $3$\\
    $(+ 2 $ $5)$\\
    $\lambda x.x$\\
    $\lambda x. (+ x $ $x)$\\
    $\lambda f. $ $f(\lambda x.(+ x $ $x ))$
\end{center}
Estas estructuras nos permiten reducir el uso de memoria de manera innecesaria, pues al no contenter
variables libres, no es necesario mantener una pila para almacenar estas.\cite{koopman1990architecture}\\
La $CFG$ de este sistema de cálculo se puede expresar de la siguiente manera en la $BNF$:\cite{clase-combinadores-calculo}:
\begin{grammar}
    <Expr> ::= S
    \alt K
    \alt I
    \alt <Expr> <Expr>
    \alt `(' <Expr> `)'
\end{grammar}
Decimos que el combinador $I$, es el combinador de la identidad, es decir, de manera formal:\cite{lambdaToSKI}
\begin{center}
    $I \; x \rightarrow x$
\end{center}
Algunos ejemplos de este combinador son:
\begin{center}
    $I \; 4 \rightarrow 4$
\end{center}
Notemos, que también es posible construir la siguiente expresión utilizando a otros combinadores, 
de la siguiente manera:
\begin{center}
    $I \; (K \; y \, x) \rightarrow K \; y \, x$
\end{center}
Para el combinador $K$, también conocido como la función canceladora, tenemos que
la regla es la siguiente\cite{koopman1990architecture}:
\begin{center}
    $K \; c \, x \rightarrow c$
\end{center}
Decimos que esta función se encarga de tomar de $2$ argumentos, y solamente regresar el primero.\cite{koopman1990architecture}\\
Un ejemplo de esto es:
\begin{center}
    $K \; 4 \, 5 \rightarrow 4$
\end{center}
Notemos, que el concepto de ignorar variables nos es muy útil para definir a los tipos booleanos, pues en estos decimos que necesitamos una 
función que realice la siguiente operación\cite{clase-combinadores-calculo}:
\begin{center}
    Verdadero $V \: x \, y \rightarrow x$\\
    Falso $F \: x \, y \rightarrow y$\\
\end{center}
Esto se puede lograr utilizando al combinador $K$ junto con otro combinador que se analiza más adelante, el combinador $S$:
\begin{center}
    $V = K$\\
    $F = S \, K$
\end{center}
Por último, se tiene al combinador $S$, el cuál se le conoce como el combinador de distribución, este se encarga de distribuir un solo argumento a
$2$ funciones, su regla es la siguiente:\cite{koopman1990architecture}
\begin{center}
    $S \: f \, g \, x \rightarrow f \, x \, (g \, x)$
\end{center}
Un ejemplo de esto compuesto con otros combinadores es:\cite{koopman1990architecture}
\begin{center}
    $S \: K \, x \, y \rightarrow (K \, y) \, (x \, y)$
\end{center}
Si se supone que se cuenta con una operación $+$ de suma, podemos visualizar un ejemplo de este combinador 
en una operación aritmética:
\begin{center}
    $S \: + \, I \, 7 \rightarrow + 7 \: (I \, 7) \rightarrow + \, (7 \, 7) \rightarrow 14$
\end{center}
Notemos, que cada término de este sistema no representa una cadena, si no representa un árbol, un ejemplo de esto 
es:\cite{clase-combinadores-calculo}
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[level distance=1.5cm,
                        level 1/.style={sibling distance=3cm},
                        level 2/.style={sibling distance=1.5cm}]
        \node {}
            child {node {}
            child {node {$S$}}
            child {node {$K$}}
            }
            child {node {}
            child {node {$x$}}
            child {node {$y$}}
        };
    \end{tikzpicture}
    \caption{Árbol para la expresión $S \: K \, x \, y$}
\end{figure}
Decimos que por eso, los paréntesis en este tipo de expresiones nos ayudan a determinar la asociación
de unas variables con otras cuando esto es necesario.\cite{clase-combinadores-calculo} Decimos que en
ausencia de paréntisis, este sistema asocia a la izquierda.\cite{clase-combinadores-calculo}\\
Una característica muy importante del cálculo SKI es que es capaz de representar a todos los programas 
computables.\cite{koopman1990architecture} Es decir, este sistema de cálculo es Turing computable.\\
Por último, observemos como SKI maneja $3$ conceptos fundamentales que nos permiten ``programar'' en el:\cite{clase-combinadores-calculo}
\begin{itemize}
    \item \textbf{Recursión}\\
        Notemos que la expresión $(S \, I \, I) \; (S \, I \, I)$ es una expresión que se puede reescribir a si misma. Pues: 
        \begin{center}
            $S \, I \, I \, x \rightarrow (I \, x) \, (I \, x) \rightarrow x \, (I \, x) \rightarrow x \, x$
        \end{center}
        Por lo que se puede definir una llamada a una función recursivamente definiendo a un $x$ como:
        \begin{center}
            $x = S (\, K \, f) \; (S (\, I \, I))$
        \end{center}
        De esta manera se puede expandir de la siguiente forma:
        \begin{center}
            $S \, I \, I \, x \rightarrow x x \rightarrow S (\, K \, f) \; (S (\, I \, I)) x \rightarrow ((K \, f) \, x) \; ((S \, I \, I) \, x) 
            \rightarrow ((K \, f) \, x) \; (x \, x) \rightarrow f \, (x \,x) \rightarrow f(f(x,x))$
        \end{center}
    \item \textbf{Condicionales}\\
        Para lograr tener un comportamiento de ramificación, es necesario contar con booleanos. Es por eso que podemos tomar la definición anterior 
        de booleanos, es decir:
        \begin{center}
           $V = K$\\
           $F = S \, K$ 
        \end{center}
        Para definir las operaciones sobre booleanos tenemos que:
        \begin{center}
            \begin{itemize}
                \item $not \, B = B \, F \, V$ en dónde $B$ es un booleano
                \item $B_1 \, or \, B_2 = B_1 \, V \, B_2$ en dónde $B$ es un booleano
                \item $B_1 \, and \, B_2 = B_1 \, B_2 \, F = B_1 \, B_2 \, (S \, K)$ en dónde $B$ es un booleano
            \end{itemize}
        \end{center}
        Ahora veamos que se puede definir a un condicional de la siguiente manera:
        \begin{center}
            $if \, B \, then \, X \, else \, Y = B \, X \, Y$
        \end{center}
    \item \textbf{Estructuras de datos}\\
        Observemos que como se realizó con las definiciones de los booleanos y las estructuras de control, podemos escribir combinadores para representar
        estructuras de datos, funciones, etc.\\
        Por ejemplo, para definir a la función $swap \,(x \, y) = y \, x$, tenemos que podemos usar al siguiente combinador $swap \, = S \, (K \, (S \, I)) (S \, (K \, K) \, I)$
\end{itemize}
\end{document}