\documentclass[main.tex]{subfiles}
\usepackage{util/estilo}

\begin{document}
SKI es un sistema de cálculo que consta de los operadores $S$, $K$ e $I$.\cite{lambdaToSKI}
Decimos que estos $3$ combinadores son supercombinadores.\cite{peytonjones1987the}\\
Un supercombinador $S$ es una expresión lambda de la forma\cite{peytonjones1987the}:
\begin{center}
    $\lambda x_1, \lambda x_2,\ldots, \lambda x_n.E$ con una aridad de $n$
\end{center}
En dónde se cumplen las siguientes condiciones:\cite{peytonjones1987the}
\begin{itemize}
    \item $S$ no cuenta con variables libres
    \item Cualquier abstracción lambda en $E$ es un supercombinador
    \item $n \geq 0$, es decir, no necesariamente cuenta con lambdas.
\end{itemize}
En otras palabras, un supercombinador es una expresión lambda que no cuenta con variables libres,
en ninguna parte y que cuenta con por lo menos un argumento.\\
Algunos ejemplos de esto son:\cite{peytonjones1987the}
\begin{center}
    $3$\\
    $(+ 2 $ $5)$\\
    $\lambda x.x$\\
    $\lambda x. (+ x $ $x)$\\
    $\lambda f. $ $f(\lambda x.(+ x $ $x ))$
\end{center}
Estas estructuras nos permiten reducir el uso de memoria de manera innecesaria, pues al no contenter
variables libres, no es necesario mantener una pila para almacenar estas.\cite{koopman1990architecture}\\
La $CFG$ de este sistema de cálculo se puede expresar de la siguiente manera en la $BNF$:\cite{clase-combinadores-calculo}:
\begin{grammar}
    <Expr> ::= S
    \alt K
    \alt I
    \alt <Expr> <Expr>
    \alt `(' <Expr> `)'
\end{grammar}
Decimos que el combinador $I$, es el combinador de la identidad, es decir, de manera formal:\cite{lambdaToSKI}
\begin{center}
    $I \; x \rightarrow x$
\end{center}
Algunos ejemplos de este combinador son:
\begin{center}
    $I \; 4 \rightarrow 4$
\end{center}
Notemos, que también es posible construir la siguiente expresión utilizando a otros combinadores, 
de la siguiente manera:
\begin{center}
    $I \; (K \; y \, x) \rightarrow K \; y \, x$
\end{center}
Para el combinador $K$, también conocido como la función canceladora, tenemos que
la regla es la siguiente\cite{koopman1990architecture}:
\begin{center}
    $K \; c \, x \rightarrow c$
\end{center}
Decimos que esta función se encarga de tomar de $2$ argumentos, y solamente regresar el primero.\cite{koopman1990architecture}\\
Un ejemplo de esto es:
\begin{center}
    $K \; 4 \, 5 \rightarrow 4$
\end{center}
Notemos, que el concepto de ignorar variables nos es muy útil para definir a los tipos booleanos, pues en estos decimos que necesitamos una 
función que realice la siguiente operación\cite{clase-combinadores-calculo}:
\begin{center}
    Verdadero $V \: x \, y \rightarrow x$\\
    Falso $F \: x \, y \rightarrow y$\\
\end{center}
Esto se puede lograr utilizando al combinador $K$ junto con otro combinador que se analiza más adelante, el combinador $S$:
\begin{center}
    $V = K$\\
    $F = SK$
\end{center}
Por último, se tiene al combinador $S$, el cuál se le conoce como el combinador de distribución, este se encarga de distribuir un solo argumento a
$2$ funciones, su regla es la siguiente:\cite{koopman1990architecture}
\begin{center}
    $S \: f \, g \, x \rightarrow f \, x \, (g \, x)$
\end{center}
Un ejemplo de esto compuesto con otros combinadores es:\cite{koopman1990architecture}
\begin{center}
    $S \: K \, x \, y \rightarrow (K \, y) \, (x \, y)$
\end{center}
Si se supone que se cuenta con una operación $+$ de suma, podemos visualizar un ejemplo de este combinador 
en una operación aritmética:
\begin{center}
    $S \: + \, I \, 7 \rightarrow + 7 \: (I \, 7) \rightarrow + \, (7 \, 7) \rightarrow 14$
\end{center}
Notemos, que cada término de este sistema no representa una cadena, si no representa un árbol, un ejemplo de esto 
es:\cite{clase-combinadores-calculo}
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[level distance=1.5cm,
                        level 1/.style={sibling distance=3cm},
                        level 2/.style={sibling distance=1.5cm}]
        \node {}
            child {node {}
            child {node {$S$}}
            child {node {$K$}}
            }
            child {node {}
            child {node {$x$}}
            child {node {$y$}}
        };
    \end{tikzpicture}
    \caption{Árbol para la expresión $S \: K \, x \, y$}
\end{figure}
Decimos que por eso, los paréntesis en este tipo de expresiones nos ayudan a determinar la asociación
de unas variables con otras cuando esto es necesario.\cite{clase-combinadores-calculo} Decimos que en
ausencia de paréntisis, este sistema asocia a la izquierda.\cite{clase-combinadores-calculo}\\
Una característica muy importante del cálculo SKI es que es capaz de representar a todos los programas 
computables.\cite{koopman1990architecture} Es decir, este sistema de cálculo es Turing computable.
\end{document}